module Proton.Xml (
Element(..),
Attribute(..),
RenderCallbackFn(..),
findAttributeValue,
getAttributes,
parseXmlFile,
render,
render'
) where

import Data.String.Utils
import Data.List (intercalate)
import Text.Regex


data Attribute = Attribute { attname :: String, attvalue :: String }
                 deriving (Show)


data Element = Root [Element]
             | RawElement String
             | Element String [Attribute] [Element]
             | ClosedElement String [Attribute]
               deriving (Show)


data RenderCallbackFn a b = RenderCallbackFn a (b -> RenderCallbackFn a b)


-- does the char in arg #2 match any of the chars in arg #1?
matches :: [Char] -> Char -> Bool
matches [] c = False
matches (x:xs) c = do
   if x == c then True
   else matches xs c


isWhitespace char = matches [' ','\n', '\t', '\r'] char


-- same as span, except the first list is loaded with elements up-to-and-including the match
spanUntil chk [] = ([], [])
spanUntil chk (x:xs) =
   if chk x then ([ x ], xs)
   else do
       let (hd, tl) = spanUntil chk xs
       ([x] ++ hd, tl)


splitOn         :: Char -> String -> (String, String)
splitOn char s = do
    let (splitA, splitB) = span (/=char) s
    if (length splitB) > 0 then (splitA, tail splitB)
    else (splitA, splitB)


-- split used for XML files, to ensure an xml tag element is a distinct member of the list returned
splitText :: String -> [String]
splitText [] = []
splitText (x:xs) = 
    if x == '<' then do
        let (first, rest) = spanUntil (=='>') xs
        [x : first] ++ splitText rest
    else do
        if isWhitespace x then do
            let (first, rest) = span (isWhitespace) xs
            [x : first] ++ splitText rest
        else do
            let (first, rest) = span (/='<') xs
            [x : first] ++ splitText rest


findAttributeValue :: String -> [Attribute] -> Maybe String
findAttributeValue name [] = Nothing
findAttributeValue name (x:xs) = do
    let aname = attname x
    let avalue = attvalue x
    if aname == name then Just avalue
    else findAttributeValue name xs


getChildren :: Element -> [Element]
getChildren (Element s atts xs) = xs
getChildren _ = []


getAttributes :: Element -> [Attribute]
getAttributes (Element s atts xs) = atts
getAttributes (ClosedElement s atts) = atts
getAttributes _ = []


-- todo: fix escaped double quote in attr value
parseAttributes      :: String -> [Attribute]
parseAttributes ""   = []
parseAttributes ">"  = []
parseAttributes " />" = []
parseAttributes "/>" = []
parseAttributes s    = do
    let news = dropWhile (matches [' ', '"']) s
    let (name, maybeValue) = splitOn '=' news
    let (value, rest) = span (not . matches ['"']) $ dropWhile (matches ['=', '"', '>']) maybeValue
    [Attribute name value] ++ if rest /= "" then parseAttributes (tail rest) else []


-- return the tag name, and then the remaining content of the element
parseTag :: String -> (String, String)
parseTag s = do
    let (_, remainder) = span (matches ['<','/']) s
    span (not . matches [' ','>', '/']) remainder


-- internal xml parser code
parse :: [String] -> ([Element], [String])
parse [] = ([], [])
parse (x:xs) = do
    let first = head x
    let sec = head (tail x)
    let seclst = last (init x)
    let lst = last x
    
    case (first, sec, seclst, lst) of
        ('<', '?', _, _)   -> do
            let (parsed, remaining) = parse xs
            ([RawElement x] ++ parsed, remaining)
        ('<', '!', _, _)   -> do
            let (parsed, remaining) = parse xs
            ([RawElement x] ++ parsed, remaining)
        ('<', _, '/', '>') -> do
            let (tag, tagcontent) = parseTag x
            let attributes = parseAttributes tagcontent
            let (parsed, remaining) = parse xs
            ([ClosedElement tag attributes] ++ parsed, remaining)
        ('<', '/', _, '>') -> ([], xs)
        ('<', _, _, '>')   -> do
            let (tag, tagcontent) = parseTag x
            let attributes = parseAttributes tagcontent
            let (children, siblings) = parse xs
            let (parsed, remaining) = parse siblings
            ([Element tag attributes children] ++ parsed, remaining)
        (_, _, _, _)       -> do
            let (parsed, remaining) = parse xs
            ([RawElement x] ++ parsed, remaining)


parseXmlFile :: String -> IO Element
parseXmlFile fname = do    
   file <- readFile fname
   let sp = splitText file
   let (parsed, _) = parse sp
   return (Root (parsed))


getData (RenderCallbackFn a b) = do
    let (tag, atts, xs) = a
    (tag, atts, xs)


getFn (RenderCallbackFn a b) = b


--renderNoop :: String -> [Attribute] -> [Element] -> (String, [Attribute], [Element])
renderNoop (s, atts, xs) = RenderCallbackFn (s, atts, xs) renderNoop


render :: Element -> String
render (RawElement s) = s
render (ClosedElement s atts) = renderClosed s atts renderNoop
render (Root xs) = renderList xs renderNoop
render (Element s atts xs) = renderOpen s atts xs renderNoop


--render' :: Element -> (String -> [Attribute] -> [Element] -> (String, [Attribute], [Element])) -> String
render' (RawElement s) fn = s
render' (ClosedElement s atts) fn = renderClosed s atts fn
render' (Root xs) fn = renderList xs fn
render' (Element s atts xs) fn = renderOpen s atts xs fn


--renderClosed :: RenderCallbackFn a b -> String
renderClosed s atts fn = do
    let fnres = fn (s, atts, [(RawElement "")])
    let (newtag, newatts, _) = getData fnres
    "<" ++ newtag ++ (renderAttributeList newatts) ++ " />"


--renderOpen :: String -> [Attribute] -> [Element] -> (String -> [Attribute] -> [Element] -> (String, [Attribute], [Element])) -> String
renderOpen s atts xs fn = do
    let fnres = fn (s, atts, xs)
    let (newtag, newatts, newxs) = getData fnres
    let newfn = getFn fnres
    "<" ++ newtag ++ (renderAttributeList newatts) ++ ">" ++ (renderList newxs newfn) ++ "</" ++ newtag ++ ">"


--renderList :: [Element] -> (String -> [Attribute] -> [Element] -> (String, [Attribute], [Element])) -> String
renderList [] fn     = ""
renderList (x:xs) fn = do
    (render' x fn) ++ (intercalate "" (map renderInternal xs))
    where renderInternal x = render' x fn


renderAttribute :: Attribute -> String
renderAttribute (Attribute name val) = " " ++ name ++ "=\"" ++ val ++ "\""

renderAttributeList :: [Attribute] -> String
renderAttributeList [] = ""
renderAttributeList (x:xs) = renderAttribute x ++ (intercalate "" (map renderAttribute xs))
